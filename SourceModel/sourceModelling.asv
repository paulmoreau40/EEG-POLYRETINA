%% Start %%
%clear all;
config4SC_Alex;
addpath(genpath('C:\Users\Alexandre\Desktop\code\mne-matlab'))

%% Parameters
% Configuration struct for ft_sourceanalyis
cfg = struct();
cfg.method = 'mne';
cfg.keeptrials = 'no'; % Only useful to keep trials info in the output struct
cfg.keepleadfield = 'yes'; % Only useful to keep leadfield info in the output struct

% Operations on the forward model (only if the leadfield is to be computed on the fly)
%cfg.reducerank = 'no'; % Reduce rank of dipole orientations if the input leadfield is free.
%cfg.backproject = 'no'; % Back project the rank reduction of the leadfield
% Depth normalization ('no' because done directly when loading the sourcemodel)
cfg.normalize = 'no';
cfg.normalizeparam = 0.9;
cfg.weight = 1;

% Parameters for mne inverse modelling
cfg.mne.noiselambda = 0; % Regularization parameter for noise covariance - only used for pre-whitening.
cfg.mne.lambda = 1e-3; % regularization parameter
% lambda is estimated from snr if not specified.
%cfg.mne.snr = 3;
cfg.mne.prewhiten = 'no';
cfg.mne.scalesourcecov = 'no';

for subject_ind = subject_inds
    if ~exist('ALLEEG','var')
        launchEEGLAB;
    end
    
    %subject_ind = 4;
    subject = study_config.subjects(subject_ind).id;
    disp(['Subject ' subject]);
    study_config.current_subject = subject_ind;
    
    % Folders and Files names:
    N = makeFolderFileNames(study_config, subject);
    
    % Load EEG data
    EEG = pop_loadset('filename', N.epochedFile, 'filepath', N.searchFolder_3arch_rej);
    data = eeglab2fieldtrip(EEG, 'raw', 'none');
        EEG_b = pop_loadset('filename', N.baselineEpochedFile, 'filepath', N.searchFolder_3arch_rej);
    data_b = eeglab2fieldtrip(EEG_b, 'raw', 'none');
    
    if isempty(study_config.subjects(subject_ind).badLocElectrodes)
        chans2remove = {};
    else
        chans2remove = study_config.subjects(subject_ind).badLocElectrodes;
    end
    
    %% Time lock analysis
    % Main data
    cfg_time = struct();
    cfg_time.channel = setdiff(data.label, chans2remove, 'stable');
    cfg_time.trials = 'all';
    cfg_time.latency = 'all';
    cfg_time.covariance = 'yes';
    cfg_time.covariancewindow = 'all';
    cfg_time.keeptrials = 'yes';
    cfg_time.removemean = 'no'; % Remove mean for covariance computation
    data_time = ft_timelockanalysis(cfg_time, data);
    
    % Noise covariance matrix
    % Calculating the average covariance matrix from each baseline trial
    cfg_b_time = struct();
    cfg_b_time.channel = setdiff(data_b.label, chans2remove, 'stable');
    cfg_b_time.trials = 'all';
    cfg_b_time.latency = 'all';
    cfg_b_time.covariance = 'yes';
    cfg_b_time.covariancewindow = 'all';
    cfg_b_time.keeptrials = 'no';
    cfg_b_time.removemean = 'yes'; % Remove mean for covariance computation
    data_b_time = ft_timelockanalysis(cfg_b_time, data_b);
    %cfg.mne.noisecov = data_b_preproc.cov; % does not work
    % Replace data covariance matrix with baseline covariance matrix
    data_time.cov = repmat(reshape(data_b_time.cov, [1,size(data_b_time.cov)]),...
        [size(data_time.trial,1),1,1]);
    %clear EEG_b data_b
    
    %% Frequency analysis
    %     cfg_freq = struct();
    %     cfg_freq.method = 'wavelet';
    %     cfg_freq.foi = 1:40; % frequencies of interest
    %     %cfg_freq.foilim = [1,40]; %frequency band of interest
    %     cfg_freq.toi = 0:0.01:1; % the times on which the analysis windows should be centered (in seconds)
    %     cfg_freq.width = 3; %(default = 7)
    %     %   cfg.gwidth     = determines the length of the used wavelets in standard
    %     %                    deviations of the implicit Gaussian kernel and should
    %     %                    be choosen >= 3; (default = 3)
    %     cfg_freq.output = 'fourier';
    %     cfg_freq.channel = setdiff(data.label, chans2remove, 'stable');
    %     cfg_freq.trials = 1:3;
    %     cfg_freq.keeptrials = 'yes';
    %     cfg_freq.keeptapers = 'yes';
    %     cfg_freq.pad = 'nextpow2';
    %     cfg_freq.polyremoval = -1;
    %     data_freq = ft_freqanalysis(cfg_freq, data);
    
    cfg_freq = struct();
    cfg_freq.method = 'superlet';
    cfg_freq.foi = study_config.ersps.FoI; % frequencies of interest
    %cfg_freq.foilim = [1,40]; %frequency band of interest
    switch study_config.epochs.window
        case 'fixed'
            step = data.time{1}(2)-data.time{1}(1);
            cfg_freq.toi = study_config.epochs.limits_wdw(1):step:study_config.epochs.limits_wdw(2);
            % the times on which the analysis windows should be centered (in seconds)
        otherwise
            error('Not implemented')
    end
    cfg_freq.superlet.basewidth = study_config.ersps.basewidth;
    % 'width', or number of cycles, of the base wavelet (default = 3)
    %cfg.superlet.gwidth     = determines the length of the used wavelets in standard
    %                             deviations of the implicit Gaussian kernel and should
    %                             be choosen >= 3; (default = 3)
    cfg_freq.superlet.combine = 'multiplicative'; % 'additive', 'multiplicative' (default = 'additive')
    %                                       determines if cycle numbers of wavelets comprising a superlet
    %                                       are chosen additively or multiplicatively
    % Cycles factors as implemented in newtimef:
    cycles_factor = linspace(1, 0.5*cfg_freq.foi(end)/cfg_freq.foi(1), length(cfg_freq.foi));
    cfg_freq.superlet.order = ceil(cycles_factor); % cfg.superlet.order = vector 1 x numfoi, superlet order, i.e. number of combined
    % wavelets, for individual frequencies of interest.
    cfg_freq.output = 'fourier';
    cfg_freq.channel = setdiff(data.label, chans2remove, 'stable');
    cfg_freq.trials = 1:5;
    cfg_freq.keeptrials = 'yes';
    cfg_freq.keeptapers = 'yes';
    cfg_freq.pad = 'nextpow2';
    cfg_freq.polyremoval = -1;
    data_freq = ft_freqanalysis(cfg_freq, data);
    %clear data
    
    %figure
    %imagesc(squeeze(abs(data_freq.fourierspctrm(1,50,:,:))));
    
    %%%%%% Only required if the leadfield is not given as input %%%%%
    % The volume conduction model of the head should be specified as
    %cfg.headmodel     = structure with volume conduction model, see FT_PREPARE_HEADMODEL
    % The EEG or MEG sensor positions can be present in the data or can be specified as
    %cfg.elec          = structure with electrode positions or filename, see FT_READ_SENS
    %%%%%%
    
    %% Params struct for loading the source model
    params = struct();
    params.chans2remove = chans2remove;
    params.fixed_ori = study_config.recon.fixed_ori;
    params.patch_space = study_config.recon.patch_space;
    params.cholesky = false;
    params.normalizeDepth = true;
    params.normalizeDepthParam = 0.9;
    params.weightWithPatchSize = false;
    [cfg.sourcemodel, cov, dipsROI] = load_sourcemodel(N, {EEG.chanlocs.labels}, params);
    if params.cholesky
        cfg.mne.sourcecov = eye(size(cov));
    else
        cfg.mne.sourcecov = cov;
    end
    
    %% Computation of source activity
    % Remove baseline from source activity
    %data_preproc.trial = data_preproc.trial - repmat(mean(data_b_preproc.avg,2)',size(data_preproc.trial,1),1,size(data_preproc.trial,3));
    stc_avg_time = ft_sourceanalysis(cfg, data_time);
    stc_avg_freq = ft_sourceanalysis(cfg, data_freq);
    
    %cfg.rawtrial = 'yes';
    %stc_trials = ft_sourceanalysis(cfg, data_preproc);
    
    %cfg.rawtrial = 'no';
    %cfg.bootstrap = 'yes';
    %cfg.numbootstrap = 50;
    %stc_bootstrapped = ft_sourceanalysis(cfg, data_preproc);
    
    % If option 1 was taken multiply solution with corr_chol
    %     if study_config.recon.fixed_ori
    %         load(fullfile(N.bemFolder, N.corrCholFile), 'corr_chol');
    %         % Wrong below: multiply mom instead of pow
    %         stc.avg.pow = corr_chol * stc.avg.pow;
    %         clear corr_chol
    %     else
    %         error('Not implemented')
    %     end
    
    %% Plot
    n_samp_smooth = 100; % 1s = 250 samples
    figure
    subplot(1,3,1)
    hold on
    plot(stc_avg_time.time,movmean(mean(stc_avg_time.avg.pow(dipsROI.PPAlh,:),1),n_samp_smooth))
    plot(stc_avg_time.time,movmean(mean(stc_avg_time.avg.pow(dipsROI.PPArh,:),1),n_samp_smooth))
    legend(study_config.recon.hemispheres)
    title('PPA')
    subplot(1,3,2)
    hold on
    plot(stc_avg_time.time,movmean(mean(stc_avg_time.avg.pow(dipsROI.RSClh,:),1),n_samp_smooth))
    plot(stc_avg_time.time,movmean(mean(stc_avg_time.avg.pow(dipsROI.RSCrh,:),1),n_samp_smooth))
    legend(study_config.recon.hemispheres)
    title('RSC')
    subplot(1,3,3)
    hold on
    plot(stc_avg_time.time,movmean(mean(stc_avg_time.avg.pow(dipsROI.OPAlh,:),1),n_samp_smooth))
    plot(stc_avg_time.time,movmean(mean(stc_avg_time.avg.pow(dipsROI.OPArh,:),1),n_samp_smooth))
    legend(study_config.recon.hemispheres)
    title('OPA')
    
    %% Plot on brain:
    %if iscell(stc.avg.mom)
    %    stc.avg.mom = cell2mat(stc.avg.mom);
    %end
    cfg_plot = struct();
    cfg_plot.funparameter = 'pow';
    %cfg_plot.maskparameter = 'mom';
    cfg_plot.method = 'surface';
    %cfg_plot.latency = 'all';
    cfg_plot.latency = [0,0.5];
    cfg_plot.avgovertime = 'yes';
    ft_sourceplot(cfg_plot, stc_avg_time);
end